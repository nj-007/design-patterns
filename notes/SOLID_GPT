The SOLID principles are a set of design principles in object-oriented programming that, when followed, can help make software systems more understandable, flexible, and maintainable. The principles are:

1. **Single Responsibility Principle (SRP)**
2. **Open/Closed Principle (OCP)**
3. **Liskov Substitution Principle (LSP)**
4. **Interface Segregation Principle (ISP)**
5. **Dependency Inversion Principle (DIP)**

Let's explore each principle with an example.

### 1. Single Responsibility Principle (SRP)
**Definition**: A class should have only one reason to change, meaning it should have only one job or responsibility.

**Example**:
Imagine a `User` class that handles both user data and sending emails.

```java
class User {
    private String name;
    private String email;

    public User(String name, String email) {
        this.name = name;
        this.email = email;
    }

    public void saveUser() {
        // Save user details to the database
    }

    public void sendWelcomeEmail() {
        // Send a welcome email to the user
    }
}
```

**Violation**:
- The `User` class has two responsibilities: handling user data and sending emails. This violates SRP.

**Refactored**:
- Split the responsibilities into two classes.

```java
class User {
    private String name;
    private String email;

    public User(String name, String email) {
        this.name = name;
        this.email = email;
    }

    public void saveUser() {
        // Save user details to the database
    }
}

class EmailService {
    public void sendWelcomeEmail(User user) {
        // Send a welcome email to the user
    }
}
```

Now, `User` is only responsible for user data, and `EmailService` is responsible for sending emails.

### 2. Open/Closed Principle (OCP)
**Definition**: Software entities (classes, modules, functions, etc.) should be open for extension but closed for modification.

**Example**:
Suppose you have a `Shape` class and want to calculate the area for different shapes.

```java
class Shape {
    public double calculateArea(String shapeType, double length, double breadth) {
        if (shapeType.equals("Rectangle")) {
            return length * breadth;
        } else if (shapeType.equals("Circle")) {
            return Math.PI * length * length; // length is the radius here
        }
        return 0;
    }
}
```

**Violation**:
- To add a new shape, you would have to modify the `calculateArea` method, which violates OCP.

**Refactored**:
- Use inheritance or interfaces to make the class open for extension.

```java
abstract class Shape {
    public abstract double calculateArea();
}

class Rectangle extends Shape {
    private double length;
    private double breadth;

    public Rectangle(double length, double breadth) {
        this.length = length;
        this.breadth = breadth;
    }

    @Override
    public double calculateArea() {
        return length * breadth;
    }
}

class Circle extends Shape {
    private double radius;

    public Circle(double radius) {
        this.radius = radius;
    }

    @Override
    public double calculateArea() {
        return Math.PI * radius * radius;
    }
}
```

Now, the `Shape` class is closed for modification but open for extension (new shapes can be added without changing existing code).

### 3. Liskov Substitution Principle (LSP)
**Definition**: Subtypes must be substitutable for their base types without altering the correctness of the program.

**Example**:
Consider a `Bird` class and its subclass `Penguin`.

```java
class Bird {
    public void fly() {
        System.out.println("Bird is flying");
    }
}

class Penguin extends Bird {
    @Override
    public void fly() {
        throw new UnsupportedOperationException("Penguins can't fly");
    }
}
```

**Violation**:
- The `Penguin` class violates LSP because it doesn't fully support the behavior of the `Bird` class. This could cause issues if a `Penguin` is treated as a `Bird`.

**Refactored**:
- Separate the flying behavior into a different class or interface.

```java
class Bird {
    // Bird-related properties and methods
}

interface Flyable {
    void fly();
}

class Sparrow extends Bird implements Flyable {
    @Override
    public void fly() {
        System.out.println("Sparrow is flying");
    }
}

class Penguin extends Bird {
    // Penguin-related properties and methods
    // No fly method because penguins can't fly
}
```

Now, `Penguin` doesn't have to override or implement any flying behavior that doesn't make sense for it.

### 4. Interface Segregation Principle (ISP)
**Definition**: No client should be forced to depend on methods it does not use. Interfaces should be specific to the clients that use them.

**Example**:
Imagine an interface `Worker` with different methods.

```java
interface Worker {
    void work();
    void eat();
}
```

**Violation**:
- If a `Robot` class implements this interface, it must provide an implementation for `eat()`, which doesn't make sense.

```java
class Robot implements Worker {
    public void work() {
        // Robot working
    }

    public void eat() {
        // Robots don't eat, so this method is unnecessary
    }
}
```

**Refactored**:
- Split the `Worker` interface into more specific interfaces.

```java
interface Workable {
    void work();
}

interface Eatable {
    void eat();
}

class HumanWorker implements Workable, Eatable {
    public void work() {
        // Human working
    }

    public void eat() {
        // Human eating
    }
}

class Robot implements Workable {
    public void work() {
        // Robot working
    }
    // No need to implement `eat()`
}
```

Now, each class implements only the methods it needs.

### 5. Dependency Inversion Principle (DIP)
**Definition**: High-level modules should not depend on low-level modules. Both should depend on abstractions (e.g., interfaces). Additionally, abstractions should not depend on details; details should depend on abstractions.

**Example**:
Consider a `LightSwitch` class that directly controls a `LightBulb`.

```java
class LightBulb {
    public void turnOn() {
        // Turn on the light bulb
    }

    public void turnOff() {
        // Turn off the light bulb
    }
}

class LightSwitch {
    private LightBulb bulb;

    public LightSwitch() {
        this.bulb = new LightBulb();
    }

    public void switchOn() {
        bulb.turnOn();
    }

    public void switchOff() {
        bulb.turnOff();
    }
}
```

**Violation**:
- The `LightSwitch` class is tightly coupled to the `LightBulb` class, violating DIP.

**Refactored**:
- Depend on an abstraction (interface) instead of a concrete class.

```java
interface Switchable {
    void turnOn();
    void turnOff();
}

class LightBulb implements Switchable {
    @Override
    public void turnOn() {
        // Turn on the light bulb
    }

    @Override
    public void turnOff() {
        // Turn off the light bulb
    }
}

class Fan implements Switchable {
    @Override
    public void turnOn() {
        // Turn on the fan
    }

    @Override
    public void turnOff() {
        // Turn off the fan
    }
}

class LightSwitch {
    private Switchable device;

    public LightSwitch(Switchable device) {
        this.device = device;
    }

    public void switchOn() {
        device.turnOn();
    }

    public void switchOff() {
        device.turnOff();
    }
}
```

Now, `LightSwitch` can work with any `Switchable` device, not just a `LightBulb`.

### Summary of SOLID Principles:
- **SRP**: A class should have one, and only one, reason to change.
- **OCP**: Software entities should be open for extension, but closed for modification.
- **LSP**: Subtypes must be substitutable for their base types.
- **ISP**: Clients should not be forced to depend on interfaces they do not use.
- **DIP**: High-level modules should depend on abstractions, not on concrete implementations. 

These principles help in designing robust, maintainable, and scalable software.



-----------------------------------------------------------------------------DIP--perfect example--------

The statement "LightSwitch can work with any Switchable device, not just a LightBulb" means that by designing the `LightSwitch` class to depend on an abstraction (the `Switchable` interface) rather than a concrete class (like `LightBulb`), we make the `LightSwitch` more flexible and reusable.

### Let's break it down:

#### Original Problem:
In the original example without the `Switchable` interface, the `LightSwitch` class was directly dependent on the `LightBulb` class. This created a tight coupling between the `LightSwitch` and `LightBulb`, meaning that `LightSwitch` could only control a `LightBulb`. If you wanted the switch to control a different device (like a fan or any other electronic device), you would have to modify the `LightSwitch` class. This is not ideal because it violates the Open/Closed Principle (OCP), where classes should be open for extension but closed for modification.

#### Solution with `Switchable` Interface:
To solve this, we introduced an interface called `Switchable`:

```java
interface Switchable {
    void turnOn();
    void turnOff();
}
```

Now, any device that can be turned on or off can implement this `Switchable` interface:

```java
class LightBulb implements Switchable {
    @Override
    public void turnOn() {
        System.out.println("LightBulb turned on");
    }

    @Override
    public void turnOff() {
        System.out.println("LightBulb turned off");
    }
}

class Fan implements Switchable {
    @Override
    public void turnOn() {
        System.out.println("Fan turned on");
    }

    @Override
    public void turnOff() {
        System.out.println("Fan turned off");
    }
}
```

#### `LightSwitch` Class:
The `LightSwitch` class now depends on the `Switchable` interface, not a specific device:

```java
class LightSwitch {
    private Switchable device;

    public LightSwitch(Switchable device) {
        this.device = device;
    }

    public void switchOn() {
        device.turnOn();
    }

    public void switchOff() {
        device.turnOff();
    }
}
```

### What Does This Achieve?

1. **Flexibility**:
   - The `LightSwitch` class can now work with any device that implements the `Switchable` interface. It could be a `LightBulb`, a `Fan`, or any other device. You just pass the desired `Switchable` object to the `LightSwitch` when creating it.

   ```java
   Switchable lightBulb = new LightBulb();
   Switchable fan = new Fan();

   LightSwitch lightSwitch1 = new LightSwitch(lightBulb);
   LightSwitch lightSwitch2 = new LightSwitch(fan);

   lightSwitch1.switchOn(); // Turns on the LightBulb
   lightSwitch2.switchOn(); // Turns on the Fan
   ```

2. **Reusability**:
   - The `LightSwitch` class doesn't need to be rewritten or modified when you want to use it with a different type of device. As long as the device implements the `Switchable` interface, the `LightSwitch` can control it.

3. **Maintainability**:
   - If you need to add a new device in the future, you simply implement the `Switchable` interface in the new device class. Thereâ€™s no need to change the `LightSwitch` class, adhering to the Open/Closed Principle.

4. **Testability**:
   - Since the `LightSwitch` depends on an interface (`Switchable`), you can easily mock the `Switchable` interface during unit testing, allowing for better testing isolation.

### Conclusion:
By depending on the `Switchable` interface rather than a concrete `LightBulb` class, the `LightSwitch` becomes more versatile and can control any device that follows the `Switchable` contract. This design approach enhances flexibility, reusability, and maintainability, making the software easier to extend and adapt to future changes.
